{"version":3,"file":"content.js","mappings":"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","sources":["webpack://interactor/./src/common/communication/sender.ts","webpack://interactor/./src/common/communication/activity.ts","webpack://interactor/./src/content/config.ts","webpack://interactor/./src/content.ts","webpack://interactor/./src/common/communication/messaging.ts","webpack://interactor/./src/common/dbdocument.ts","webpack://interactor/./src/content/monitor.ts","webpack://interactor/./src/content/pagedata.ts","webpack://interactor/webpack/bootstrap","webpack://interactor/webpack/startup"],"sourcesContent":["enum SenderMethod {\n  InitializeSession = \"Initialize Session\",\n  InteractionDetection = \"Interaction Detection\",\n  NavigationDetection = \"Navigation Detection\",\n  CloseSession = \"Close Session\",\n  Any = \"Any\",\n}\nexport { SenderMethod }\n","/**\n * Defines a list of the possible activity types that can be recorded by the Monitor class\n */\nenum ActivityType {\n  SelfLoop = \"Self-Loop\",\n  StateChange = \"State Change\",\n  Interaction = \"Interaction\",\n  Both = \"Both\",\n}\n\nexport { ActivityType }\n","import { SenderMethod } from \"../common/communication/sender\"\nimport { ExtractedMetadata } from \"../common/dbdocument\"\n\nexport {\n  Config,\n  ConfigLoader,\n  URLPatternToSelectors,\n  SelectorNamePair,\n  ExtractorData,\n  ExtractorList,\n}\n\ninterface SelectorNamePair {\n  selector: string\n  name: string\n}\ntype URLPatternToSelectors = Record<string, SelectorNamePair[]>\n\ninterface Config {\n  /**\n   * An interface that contains all the data required to instantiate a Monitor.\n   */\n  // The base URL that the monitor should start at\n  baseURL: string\n  // A mapping of URL patterns to path data. The URL Pattern should follow the\n  // URL Pattern API syntax. These are appended to the baseURL when checking for matches\n  // Ex: baseURL: www.youtube.com, path: /shorts/:id -> www.youtube.com/shorts/:id\n  paths: URLPatternToSelectors\n  // Indicates whether the Monitor should be in debug mode. If true, add coloured boxes\n  // around selected HTML elements\n  debug?: boolean\n  // A list of event types to monitor. By default, this is just [\"click\"]\n  events?: string[]\n}\n\nclass ExtractorData {\n  eventType: SenderMethod\n  urlPattern: string\n  extractor: () => ExtractedMetadata\n  constructor(\n    activityType: SenderMethod,\n    urlPattern: string,\n    extractor: () => ExtractedMetadata,\n  ) {\n    this.eventType = activityType\n    this.urlPattern = urlPattern\n    this.extractor = extractor\n  }\n}\n\nclass ExtractorList {\n  private extractors: ExtractorData[]\n  private baseURL: string\n  constructor(extractors: ExtractorData[] = [], baseURL: string) {\n    this.extractors = extractors\n    this.baseURL = baseURL\n  }\n\n  public extract(\n    currentURL: string,\n    eventType: SenderMethod,\n  ): ExtractedMetadata {\n    console.log(\n      `Attempting extraction for url: ${currentURL} and event type ${eventType}`,\n    )\n    let extractedData: ExtractedMetadata = {}\n    this.extractors\n      .filter((e) => {\n        const isCorrectActivity: boolean =\n          e.eventType == eventType || e.eventType == SenderMethod.Any\n        const p: URLPattern = new URLPattern(e.urlPattern, this.baseURL)\n        const isURLMatch: boolean = p.test(currentURL)\n        return isCorrectActivity && isURLMatch\n      })\n      .forEach(\n        (e) =>\n          (extractedData = {\n            ...(extractedData as object),\n            ...(e.extractor() as object),\n          }),\n      )\n    return extractedData\n  }\n}\n\nclass ConfigLoader {\n  public config: Config\n  public extractorList: ExtractorList\n\n  constructor(config: Config, extractorList: ExtractorData[] = []) {\n    this.config = config\n    this.extractorList = new ExtractorList(extractorList, config.baseURL)\n  }\n}\n","import { Monitor } from \"./content/monitor\"\nimport ytConfig from \"./content/configs/youtube_config.json\"\nimport personalConfig from \"./content/configs/personal_site.json\"\n// import tiktokConfig from './configs/tiktok_config.json';\n// import linkedinConfig from './configs/linkedin_config.json';\nimport { ConfigLoader, ExtractorData } from \"./content/config\"\n// import { ActivityType } from \"./communication/activity\";\nimport { SenderMethod } from \"./common/communication/sender\"\nimport { ExtractedMetadata } from \"./common/dbdocument\"\n\nconst getHomepageVideos = (): ExtractedMetadata => {\n  // console.log(\"---- EXTRACTING HOMEPAGE LINKS ---\");\n  const contentDivs = Array.from(\n    document.querySelectorAll(\"#content.ytd-rich-item-renderer\"),\n  ).filter((div) => {\n    // Check if element is actually visible\n    const rect = div.getBoundingClientRect()\n    return (\n      rect.width > 0 &&\n      rect.height > 0 &&\n      getComputedStyle(div).visibility !== \"hidden\"\n    )\n  })\n\n  const videos = contentDivs\n    .map((contentDiv) => {\n      // Get the direct anchor child\n      const anchor = contentDiv.querySelector(\n        \":scope > yt-lockup-view-model a\",\n      ) as HTMLAnchorElement\n      const span = contentDiv.querySelector(\n        \"h3 a span.yt-core-attributed-string\",\n      )\n\n      return {\n        link: anchor?.href ?? \"\",\n        title: span?.textContent?.trim() ?? \"\",\n      }\n    })\n    .filter((video) => video.link !== \"\")\n  const metadata: ExtractedMetadata = { videos: videos }\n  return metadata\n}\n\nconst getRecommendedVideos = (): ExtractedMetadata => {\n  console.log(\"---- EXTRACTING RECOMMENDED LINKS ----\")\n  const contentDivs = Array.from(\n    document.querySelectorAll(\"yt-lockup-view-model\"),\n  ).filter((div) => {\n    // Check if element is actually visible\n    const rect = div.getBoundingClientRect()\n    return (\n      rect.width > 0 &&\n      rect.height > 0 &&\n      getComputedStyle(div).visibility !== \"hidden\"\n    )\n  })\n\n  const videos: ExtractedMetadata = contentDivs\n    .map((contentDiv) => {\n      // Get the anchor with the video link\n      const anchor = contentDiv.querySelector(\n        'a[href^=\"/watch\"]',\n      )! as HTMLAnchorElement\n      const span = contentDiv.querySelector(\n        \"h3 a span.yt-core-attributed-string\",\n      )!\n\n      return {\n        link: anchor?.href ?? \"\",\n        title: span?.textContent?.trim() ?? \"\",\n      }\n    })\n    .filter((video) => video.link !== \"\")\n\n  // console.log(\"Printing the first 5 videos\");\n  // console.table(videos.slice(0,5));\n  const metadata: ExtractedMetadata = { videos: videos }\n  return metadata\n}\n\nconst extractors = [\n  new ExtractorData(SenderMethod.InteractionDetection, \"/\", getHomepageVideos),\n  new ExtractorData(\n    SenderMethod.InteractionDetection,\n    \"/watch?v=*\",\n    getRecommendedVideos,\n  ),\n]\n\nconst ytConfigLoader = new ConfigLoader(ytConfig, extractors)\n\nnew Monitor(ytConfigLoader)\n\nconst personalConfigLoader = new ConfigLoader(personalConfig, [])\nnew Monitor(personalConfigLoader)\n\n// const tiktokIDSelector = (): object => {\n//     let vid = document.querySelector(\"div.xgplayer-container.tiktok-web-player\");\n//     if (!vid){\n//         console.log(\"no url found!\");\n//         return {};\n//     }\n//     let id = vid.id.split(\"-\").at(-1);\n//     let url = `https://tiktok.com/share/video/${id}`;\n//     return {\n//         \"uniqueURL\": url\n//     };\n// }\n\n// console.log(tiktokConfig);\n// const tiktokConfigLoader = new ConfigLoader(tiktokConfig);\n// tiktokConfigLoader.injectExtractor(\"/*\", tiktokIDSelector);\n// const tiktokInteractor = new Monitor(tiktokConfigLoader.config);\n\n// // console.log(tiktokConfig);\n// const linkedinConfigLoader = new ConfigLoader(linkedinConfig);\n// const linkedinInteractor = new Monitor(linkedinConfigLoader.config);\n","import { DBDocument } from \"../dbdocument\"\nimport { SenderMethod } from \"./sender\"\nexport { MessageToBackground, MessageResponse }\n/**\n * A class used to send messages from the content to the background script in a consistent format.\n */\nclass MessageToBackground {\n  senderMethod: SenderMethod\n  payload: DBDocument\n  /**\n   * @param senderMethod - enum type of the method sending the message\n   * @param payload - the data being sent to the database\n   */\n  constructor(senderMethod: SenderMethod, payload: DBDocument) {\n    this.senderMethod = senderMethod\n    this.payload = payload\n  }\n}\n\ninterface MessageResponse {\n  status: string\n  highlight?: boolean\n}\n","import { ActivityType } from \"./communication/activity\"\n/**\n * A class defining documents that are sent to the database from the content script\n */\nclass DBDocument {\n  // URL at whicht the event was created\n  sourceURL: string\n  sourceDocumentTitle: string\n\n  constructor(url: string, title: string) {\n    this.sourceURL = url\n    this.sourceDocumentTitle = title\n  }\n}\n\ninterface ExtractedMetadataObject {\n  [key: string]: ExtractedMetadata\n}\n\ntype ExtractedMetadata =\n  | string\n  | ExtractedMetadata[]\n  | ExtractedMetadataObject\n  | Record<string, string> // explicitly allow objects with string values\n\n/**\n * A child of DBDocument that represents activities\n */\n\nclass ActivityDocument extends DBDocument {\n  // The type of activity being logged. Either \"state_chage\", \"self_loop\", or \"interaction\"\n  activityType: ActivityType | string\n  // Timestamp for when the document was created\n  createdAt: Date | string\n  // Event type (eg. click, scroll, etc...)\n  eventType: string\n  // Metadata about the event\n  metadata?: ExtractedMetadata\n  constructor(\n    type: ActivityType,\n    event: Event,\n    metadata: ExtractedMetadata,\n    url: string,\n    title: string,\n  ) {\n    super(url, title)\n    this.activityType = type\n    this.createdAt = new Date()\n    this.eventType = event.type\n    this.metadata = metadata\n  }\n}\n\n/**\n * A child of DBDocument that represents the start of a session\n */\n\nclass SessionDocument extends DBDocument {\n  startTime: Date | null\n  endTime?: Date | null\n  email: string | null = null\n  constructor(sourceURL: string, sourceDocumentTitle: string) {\n    super(sourceURL, sourceDocumentTitle)\n    this.startTime = new Date()\n  }\n  setEmail(email: string) {\n    this.email = email\n  }\n}\n\nexport { DBDocument, ActivityDocument, SessionDocument, ExtractedMetadata }\n","import {\n  MessageToBackground,\n  MessageResponse,\n} from \"../common/communication/messaging\"\nimport {\n  DBDocument,\n  ActivityDocument,\n  SessionDocument,\n  ExtractedMetadata,\n} from \"../common/dbdocument\"\nimport { ConfigLoader, ExtractorList } from \"./config\"\nimport { PageData } from \"./pagedata\"\nimport { ActivityType } from \"../common/communication/activity\"\nimport { SenderMethod } from \"../common/communication/sender\"\n\n/**\n * This class reads from a provided Config object and attaches listeners to the elements specified in the selectors.\n * When these elements are interacted with, or when a navigation occurs, a document is sent to the background script\n * to be appended to the database. This class is instantiated in content.ts.\n *\n * @param interactionEvents - A list of the type of events we want to monitor as interactions (eg. click, scroll, etc.). Default is click\n * @param debug - If true, highlight all selected HTML elements with coloured boxes\n * @param paths - An object mapping path patterns to their corresponding CSS selectors Path patterns are consistent with the  URL Pattern API Syntax: https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API\n * @param baseURL - Base url for the page (eg. www.youtube.com). All paths are appended to this when matching URls\n * @param currentPageData - Contains data relevant to the current page.\n * @param interactionAttribute - Attribute added to all elements being monitored\n */\nexport class Monitor {\n  // A list of the type of events we want to monitor as interactions (eg. click, scroll, etc.). Default is click\n  htmlEventsToMonitor: string[]\n  // If true, highlight all selected HTML elements with coloured boxes\n  enableHighlighting: boolean\n  // Contains data relevant to the current page.\n  currentPageData: PageData\n  // Attribute added to all elements being monitored\n  htmlMonitoringAttribute: string\n\n  extractorList: ExtractorList\n\n  constructor(configLoader: ConfigLoader) {\n    const config = configLoader.config\n    this.htmlEventsToMonitor = config.events ?? [\"click\"]\n    this.enableHighlighting = true\n    this.currentPageData = new PageData(config)\n    this.htmlMonitoringAttribute = \"monitoring-interactions\"\n    this.extractorList = configLoader.extractorList\n    // Only initialize monitor if the URL matches and\n    // the content of the page is visible\n    if (window.location.origin === config.baseURL) {\n      this.intitializeWhenVisible()\n    }\n  }\n\n  private intitializeWhenVisible(): void {\n    const runWhenVisible = () => {\n      if (document.visibilityState === \"visible\") {\n        this.initializeMonitor()\n          .then(() => {\n            document.removeEventListener(\"visibilitychange\", runWhenVisible)\n          })\n          .catch((error) => {\n            console.error(\"Error initializing monitor:\", error)\n            // Still remove listener even if there's an error\n            document.removeEventListener(\"visibilitychange\", runWhenVisible)\n          })\n      }\n    }\n\n    if (document.readyState === \"complete\") {\n      runWhenVisible() // This will now be synchronous\n    } else {\n      window.addEventListener(\"load\", () => {\n        runWhenVisible()\n      })\n    }\n\n    document.addEventListener(\"visibilitychange\", runWhenVisible)\n  }\n\n  /**\n   * Initializes the monitor\n   */\n  private async initializeMonitor() {\n    console.log(\"initializing monitor\")\n    this.currentPageData.update(document.location.href)\n    try {\n      // Creates a new entry in the DB describing the state at the start of the session\n      await this.initializeSession()\n      // Binds listeners to the HTML elements specified in the config for all matching path patterns\n      this.bindEvents()\n    } catch (err) {\n      console.error(\"Failed to initialize session:\", err)\n    }\n  }\n\n  /**\n   * Creates a new entry in the DB describing the state at the start of the session\n   */\n  private async initializeSession(): Promise<void> {\n    const currentState: DBDocument = new SessionDocument(\n      this.currentPageData.currentURL,\n      document.title,\n    )\n    console.log(\"Checking highlight\")\n    const response: MessageResponse | null = await this.sendMessageToBackground(\n      SenderMethod.InitializeSession,\n      currentState,\n    )\n    if (\n      response &&\n      response?.status === \"Session initialized\" &&\n      response.highlight\n    ) {\n      this.enableHighlighting = response.highlight\n    }\n    console.log(`Highlight is set to ${this.enableHighlighting}`)\n  }\n\n  /**\n   * Binds event listeners for mutations and navigation\n   */\n\n  private bindEvents(): void {\n    // Whenever new content is loaded, attach observers to each HTML element that matches the selectors in the configs\n    const observer: MutationObserver = new MutationObserver(() =>\n      this.addListenersToNewMatches(),\n    )\n    // Make the mutation observer observe the entire document for changes\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    })\n\n    // Add an event listener to detect navigations on the page\n    navigation.addEventListener(\"navigate\", (e: NavigationEvent) =>\n      this.onNavigationDetection(e),\n    )\n  }\n\n  /**\n   * Adds listeners to mutations (ie. newly rendered elements) and marks them with this.interacttionAttribute.\n   * If debug mode is on, this will add a colourful border to these elements.\n   */\n\n  private addListenersToNewMatches(): void {\n    // console.log(\"adding selectors\");\n    // console.log(`Value of highlight: ${this.highlight}`);\n    // console.log(\"Current page data:\");\n    // console.log(this.currentPageData);\n    this.currentPageData.selectorNamePairs.forEach((selectorNamePair) => {\n      const elements: NodeListOf<HTMLElement> = document.querySelectorAll(\n        `:is(${selectorNamePair.selector}):not([${this.htmlMonitoringAttribute}])`,\n      )\n      const name: string = selectorNamePair.name\n      for (const element of elements) {\n        if (this.enableHighlighting) {\n          element.style.border = `2px solid ${this.StringToColor.next(name)}`\n        }\n        element.setAttribute(this.htmlMonitoringAttribute, \"true\")\n\n        for (const ie of this.htmlEventsToMonitor) {\n          element.addEventListener(\n            ie,\n            (e: Event) => {\n              this.onInteractionDetection(element, e, name)\n            },\n            true,\n          )\n        }\n      }\n    })\n  }\n\n  /**\n   * Sends a message to the background script.\n   * @param activityType -  the type of activity (self loop or state change)\n   * @param event - the HTML event that occured\n   *\n   * @returns A document describing self loop\n   */\n\n  private createNavigationRecord(\n    activityType: ActivityType,\n    event: Event,\n  ): DBDocument {\n    const metadata = this.extractorList.extract(\n      this.currentPageData.currentURL, // runs for \"prev page\"\n      SenderMethod.NavigationDetection,\n    )\n    console.log(\"printing metadata\")\n    console.log(metadata)\n    return new ActivityDocument(\n      activityType,\n      event,\n      metadata,\n      this.currentPageData.currentURL,\n      document.title,\n    )\n  }\n\n  /**\n   * Sends a message to the background script.\n   * @param element - the element that triggered the event\n   * @param name - the name of the element that triggered the callback (as defined in the config)\n   * @param event - the HTML event that occured\n   * @returns A document interaction self loop\n   */\n\n  private createInteractionRecord(name: string, event: Event): DBDocument {\n    console.log(\"Detected interaction event\")\n    const pageSpecificData: object = {\n      elementName: name,\n    }\n    const extractedData = this.extractorList.extract(\n      this.currentPageData.currentURL,\n      SenderMethod.InteractionDetection,\n    )\n\n    const metadata: ExtractedMetadata = {\n      ...pageSpecificData,\n      ...(extractedData as object),\n    } as ExtractedMetadata\n\n    console.log(\"printing metadata\")\n    console.log(metadata)\n\n    return new ActivityDocument(\n      ActivityType.Interaction,\n      event,\n      metadata,\n      this.currentPageData.currentURL,\n      document.title,\n    )\n  }\n\n  /**\n   * Sends a message to the background script.\n   * @param senderMethod - the name of the function that's sending the message to the background script\n   * @param payload - the data being sent to the background script\n   *\n   * @returns Response indicating whether the message succeeded\n   */\n\n  private async sendMessageToBackground(\n    senderMethod: SenderMethod,\n    payload: DBDocument,\n  ): Promise<MessageResponse | null> {\n    try {\n      // Check if runtime is available (extension context still valid)\n      if (!chrome.runtime?.id) {\n        throw new Error(\"Extension context invalidated\")\n      }\n\n      const message: MessageToBackground = new MessageToBackground(\n        senderMethod,\n        payload,\n      )\n      const response: MessageResponse =\n        await chrome.runtime.sendMessage(message)\n\n      // Chrome returns undefined if no listeners, check if that's expected\n      if (response === undefined) {\n        console.error(\"No response from background script\")\n      }\n      return response\n    } catch (error) {\n      console.error(\"Background message failed:\", error)\n      // Decide whether to throw or handle gracefully based on your needs\n      return null // or throw error;\n    }\n  }\n\n  /**\n   * Callback that creates a payload describing the interaction that occured and sends it to the background script\n   * @param element - the event that triggered the callback\n   * @param name - the name of the element that triggered the callback (as defined in the config)\n   */\n\n  private onInteractionDetection(\n    element: Element,\n    event: Event,\n    name: string,\n  ): void {\n    console.log(\"interaction event detected\")\n    console.log(`Event detected with event type: ${event.type}`)\n    console.log(`Event triggered by`, element)\n    // console.log(element.innerHTML);\n    // console.log(element.getHTML());\n    const record: DBDocument = this.createInteractionRecord(name, event)\n    this.sendMessageToBackground(\n      SenderMethod.InteractionDetection,\n      record,\n    ).catch((error) => {\n      console.error(\"Failed to send interaction data:\", error)\n    })\n  }\n\n  private isNewBaseURL(newURL: string | null): boolean {\n    console.log(\"checking if url updated\")\n    if (newURL === null) {\n      console.log(\"new url is null\")\n      return false\n    }\n    const currentHostname = new URL(this.currentPageData.currentURL).hostname\n    const newHostname = new URL(newURL).hostname\n\n    console.log(\"current hostname\", currentHostname)\n    console.log(\"new hostname\", newHostname)\n\n    return currentHostname !== newHostname\n  }\n\n  /**\n   * Callback that creates a payload describing the navigation that occured and sends it to the background script\n   * @param navEvent - the event that triggered the callback\n   */\n  private onNavigationDetection(navEvent: NavigationEvent): void {\n    const destUrl: string | null = navEvent.destination.url\n    const baseURLChange: boolean = this.isNewBaseURL(destUrl)\n    let record: DBDocument | undefined = undefined\n    let sender: SenderMethod | undefined = undefined\n\n    console.log(\n      `before creating nav record, current URL is ${this.currentPageData.currentURL}`,\n    )\n    if (baseURLChange) {\n      console.log(\"URL base change detected. Closing program.\")\n      record = new DBDocument(this.currentPageData.currentURL, document.title)\n      sender = SenderMethod.CloseSession\n    } else if (navEvent.navigationType === \"push\") {\n      console.log(\"Push event detected.\")\n      record = this.createNavigationRecord(ActivityType.StateChange, navEvent)\n      sender = SenderMethod.NavigationDetection\n    } else if (navEvent.navigationType === \"replace\") {\n      console.log(\"Replace event detected.\")\n      record = this.createNavigationRecord(ActivityType.SelfLoop, navEvent)\n      sender = SenderMethod.NavigationDetection\n    }\n\n    console.log(\n      `after creating nav record, current URL is ${this.currentPageData.currentURL}`,\n    )\n\n    if (destUrl) {\n      this.currentPageData.update(destUrl)\n    }\n\n    console.log(\n      `at end of on nav detect, current URL is ${this.currentPageData.currentURL}`,\n    )\n\n    if (typeof record !== \"undefined\" && typeof sender !== \"undefined\") {\n      this.sendMessageToBackground(sender, record).catch((error) => {\n        console.error(\"Failed to send interaction data:\", error)\n      })\n    }\n  }\n\n  /**\n   * Generates a unique color from a given string\n   * Source: https://stackoverflow.com/a/31037383\n   * @returns Color hex code\n   */\n\n  private StringToColor = (function () {\n    interface ColorInstance {\n      stringToColorHash: Record<string, string>\n      nextVeryDifferntColorIdx: number\n      veryDifferentColors: string[]\n    }\n\n    let instance: ColorInstance | null = null\n\n    return {\n      next: function stringToColor(str: string): string {\n        instance ??= {\n          stringToColorHash: {},\n          nextVeryDifferntColorIdx: 0,\n          veryDifferentColors: [\n            \"#00FF00\",\n            \"#0000FF\",\n            \"#FF0000\",\n            \"#01FFFE\",\n            \"#FFA6FE\",\n            \"#FFDB66\",\n            \"#006401\",\n            \"#010067\",\n            \"#95003A\",\n            \"#007DB5\",\n            \"#FF00F6\",\n            \"#FFEEE8\",\n            \"#774D00\",\n            \"#90FB92\",\n            \"#0076FF\",\n            \"#D5FF00\",\n            \"#FF937E\",\n            \"#6A826C\",\n            \"#FF029D\",\n            \"#FE8900\",\n            \"#7A4782\",\n            \"#7E2DD2\",\n            \"#85A900\",\n            \"#FF0056\",\n            \"#A42400\",\n            \"#00AE7E\",\n            \"#683D3B\",\n            \"#BDC6FF\",\n            \"#263400\",\n            \"#BDD393\",\n            \"#00B917\",\n            \"#9E008E\",\n            \"#001544\",\n            \"#C28C9F\",\n            \"#FF74A3\",\n            \"#01D0FF\",\n            \"#004754\",\n            \"#E56FFE\",\n            \"#788231\",\n            \"#0E4CA1\",\n            \"#91D0CB\",\n            \"#BE9970\",\n            \"#968AE8\",\n            \"#BB8800\",\n            \"#43002C\",\n            \"#DEFF74\",\n            \"#00FFC6\",\n            \"#FFE502\",\n            \"#620E00\",\n            \"#008F9C\",\n            \"#98FF52\",\n            \"#7544B1\",\n            \"#B500FF\",\n            \"#00FF78\",\n            \"#FF6E41\",\n            \"#005F39\",\n            \"#6B6882\",\n            \"#5FAD4E\",\n            \"#A75740\",\n            \"#A5FFD2\",\n            \"#FFB167\",\n            \"#009BFF\",\n            \"#E85EBE\",\n          ],\n        }\n\n        if (!instance.stringToColorHash[str]) {\n          instance.stringToColorHash[str] =\n            instance.veryDifferentColors[instance.nextVeryDifferntColorIdx++]\n          console.log(\n            `%c The colour for ${str}`,\n            `color: ${instance.stringToColorHash[str]}`,\n          )\n        }\n        return instance.stringToColorHash[str]\n      },\n    }\n  })()\n}\n","import { URLPatternToSelectors, SelectorNamePair, Config } from \"./config\"\n/**\n * A class responsible for tracking the state of the page that the user is currently on.\n */\nexport class PageData {\n  // Current URL of the page\n  currentURL!: string\n  // CSS selectors being applied to the page\n  selectorNamePairs!: SelectorNamePair[]\n  baseURL: string\n  urlPatternToSelectorData: URLPatternToSelectors\n\n  constructor(config: Config) {\n    this.urlPatternToSelectorData = config.paths\n    this.baseURL = config.baseURL\n  }\n  /**\n   * Updates the URL and the list of CSS selectors for the URL\n   * @param newURL: The full url of the current page\n   */\n  update(newURL: string) {\n    this.currentURL = newURL\n    const matchingURLPatterns: string[] = this.getMatchingPatterns()\n    this.selectorNamePairs = this.getSelectorNamePairs(matchingURLPatterns)\n  }\n  /**\n   * Sets `matchPathData` to be the PathData for the URL pattern with the closet match to `this.baseURL`\n   * and returns a list of all matches. Additionally, it updates whether the current path\n   * includes an id.\n   *\n   * @returns A list of all patterns in the config that match `baseURL`\n   */\n\n  private getMatchingPatterns(): string[] {\n    console.log(\"updating page data\")\n\n    // Get a list of all the paths that match the current URL\n    const matchingURLPatterns: string[] = Object.keys(\n      this.urlPatternToSelectorData,\n    ).filter((path) => {\n      // console.log(path);\n      const pattern: URLPattern = new URLPattern(path, this.baseURL)\n      const match: boolean = pattern.test(this.currentURL)\n      return match\n    })\n\n    if (matchingURLPatterns.length === 0) {\n      console.log(\"no matches found\")\n    }\n\n    return matchingURLPatterns\n  }\n\n  /**\n   * @param matchingURLPatterns: A list of all matching paths to the current url\n   *\n   * @returns A list of all selectors for the matching paths\n   */\n\n  private getSelectorNamePairs(\n    matchingURLPatterns: string[],\n  ): SelectorNamePair[] {\n    let currentSelectorNamePairs: SelectorNamePair[] = []\n    for (const urlPattern of matchingURLPatterns) {\n      const selectorNamePairs: SelectorNamePair[] =\n        this.urlPatternToSelectorData[urlPattern]\n      currentSelectorNamePairs =\n        currentSelectorNamePairs.concat(selectorNamePairs)\n    }\n    return currentSelectorNamePairs\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(481);\n"],"names":["SenderMethod","ActivityType","ExtractorData","constructor","activityType","urlPattern","extractor","this","eventType","ExtractorList","extractors","baseURL","extract","currentURL","console","log","extractedData","filter","e","isCorrectActivity","Any","isURLMatch","URLPattern","test","forEach","ConfigLoader","config","extractorList","InteractionDetection","videos","Array","from","document","querySelectorAll","div","rect","getBoundingClientRect","width","height","getComputedStyle","visibility","map","contentDiv","anchor","querySelector","span","link","href","title","textContent","trim","video","ytConfigLoader","Monitor","personalConfigLoader","MessageToBackground","senderMethod","payload","DBDocument","url","sourceURL","sourceDocumentTitle","ActivityDocument","type","event","metadata","super","createdAt","Date","SessionDocument","email","startTime","setEmail","configLoader","StringToColor","instance","next","str","stringToColorHash","nextVeryDifferntColorIdx","veryDifferentColors","htmlEventsToMonitor","events","enableHighlighting","currentPageData","PageData","htmlMonitoringAttribute","window","location","origin","intitializeWhenVisible","runWhenVisible","visibilityState","initializeMonitor","then","removeEventListener","catch","error","readyState","addEventListener","update","initializeSession","bindEvents","err","currentState","response","sendMessageToBackground","InitializeSession","status","highlight","MutationObserver","addListenersToNewMatches","observe","body","childList","subtree","navigation","onNavigationDetection","selectorNamePairs","selectorNamePair","elements","selector","name","element","style","border","setAttribute","ie","onInteractionDetection","createNavigationRecord","NavigationDetection","createInteractionRecord","pageSpecificData","elementName","Interaction","chrome","runtime","id","Error","message","sendMessage","undefined","record","isNewBaseURL","newURL","currentHostname","URL","hostname","newHostname","navEvent","destUrl","destination","baseURLChange","sender","CloseSession","navigationType","StateChange","SelfLoop","urlPatternToSelectorData","paths","matchingURLPatterns","getMatchingPatterns","getSelectorNamePairs","Object","keys","path","length","currentSelectorNamePairs","concat","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}
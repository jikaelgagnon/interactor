{"version":3,"file":"content.bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://interactor/./src/communication/activity.ts","webpack://interactor/./src/communication/backgroundmessage.ts","webpack://interactor/./src/communication/sender.ts","webpack://interactor/./src/database/dbdocument.ts","webpack://interactor/./src/interactions/config.ts","webpack://interactor/./src/interactions/monitor.ts","webpack://interactor/./src/interactions/pagedata.ts","webpack://interactor/webpack/bootstrap","webpack://interactor/webpack/runtime/define property getters","webpack://interactor/webpack/runtime/hasOwnProperty shorthand","webpack://interactor/webpack/runtime/make namespace object","webpack://interactor/./src/content.ts"],"sourcesContent":["/**\n * Defines a list of the possible activity types that can be recorded by the Monitor class\n */\nvar ActivityType;\n(function (ActivityType) {\n    ActivityType[\"SelfLoop\"] = \"Self-Loop\";\n    ActivityType[\"StateChange\"] = \"State Change\";\n    ActivityType[\"Interaction\"] = \"Interaction\";\n    ActivityType[\"Both\"] = \"Both\";\n})(ActivityType || (ActivityType = {}));\nexport { ActivityType };\n","export { BackgroundMessage };\n/**\n * A class used to send messages from the content to the background script in a consistent format.\n */\nclass BackgroundMessage {\n    /**\n     * @param senderMethod - enum type of the method sending the message\n     * @param payload - the data being sent to the database\n     */\n    constructor(senderMethod, payload) {\n        this.senderMethod = senderMethod;\n        this.payload = payload;\n    }\n}\n","var SenderMethod;\n(function (SenderMethod) {\n    SenderMethod[\"InitializeSession\"] = \"Initialize Session\";\n    SenderMethod[\"InteractionDetection\"] = \"Interaction Detection\";\n    SenderMethod[\"NavigationDetection\"] = \"Navigation Detection\";\n    SenderMethod[\"CloseSession\"] = \"Close Session\";\n    SenderMethod[\"Any\"] = \"Any\";\n})(SenderMethod || (SenderMethod = {}));\nexport { SenderMethod };\n","/**\n * A class defining documents that are sent to the database from the content script\n */\nclass DBDocument {\n    constructor(url, title) {\n        this.sourceURL = url;\n        this.sourceDocumentTitle = title;\n    }\n}\n/**\n * A child of DBDocument that represents activities\n */\nclass ActivityDocument extends DBDocument {\n    constructor(type, event, metadata, url, title) {\n        super(url, title);\n        this.activityType = type;\n        this.createdAt = new Date();\n        this.eventType = event.type;\n        this.metadata = metadata;\n    }\n}\n/**\n * A child of DBDocument that represents the start of a session\n */\nclass SessionDocument extends DBDocument {\n    constructor(url, title) {\n        super(url, title);\n        this.email = \"Email not set\";\n        this.startTime = new Date();\n    }\n    setEmail(email) {\n        this.email = email;\n    }\n}\nexport { DBDocument, ActivityDocument, SessionDocument };\n","import { SenderMethod } from \"../communication/sender\";\nexport { ConfigLoader, ExtractorData, ExtractorList };\nclass ExtractorData {\n    constructor(activityType, urlPattern, extractor) {\n        this.eventType = activityType;\n        this.urlPattern = urlPattern;\n        this.extractor = extractor;\n    }\n}\nclass ExtractorList {\n    constructor(extractors = [], baseURL) {\n        this.extractors = extractors;\n        this.baseURL = baseURL;\n    }\n    extract(currentURL, eventType) {\n        console.log(`Attempting extraction for url: ${currentURL} and event type ${eventType}`);\n        let extractedData = {};\n        this.extractors.filter(e => {\n            const isCorrectActivity = (e.eventType == eventType || e.eventType == SenderMethod.Any);\n            // @ts-ignore: Ignoring TypeScript error for URLPattern not found\n            const p = new URLPattern(e.urlPattern, this.baseURL);\n            const isURLMatch = p.test(currentURL);\n            return isCorrectActivity && isURLMatch;\n        }).forEach(e => extractedData = Object.assign(Object.assign({}, extractedData), e.extractor()));\n        return extractedData;\n    }\n}\nclass ConfigLoader {\n    constructor(config, extractorList = []) {\n        this.config = config;\n        this.extractorList = new ExtractorList(extractorList, config.baseURL);\n    }\n}\n","import { BackgroundMessage } from \"../communication/backgroundmessage\";\nimport { DBDocument, ActivityDocument, SessionDocument } from \"../database/dbdocument\";\nimport { PageData } from \"./pagedata\";\nimport { ActivityType } from \"../communication/activity\";\nimport { SenderMethod } from \"../communication/sender\";\n/**\n * This class reads from a provided Config object and attaches listeners to the elements specified in the selectors.\n * When these elements are interacted with, or when a navigation occurs, a document is sent to the background script\n * to be appended to the database. This class is instantiated in content.ts.\n *\n * @param interactionEvents - A list of the type of events we want to monitor as interactions (eg. click, scroll, etc.). Default is click\n * @param debug - If true, highlight all selected HTML elements with coloured boxes\n * @param paths - An object mapping path patterns to their corresponding CSS selectors Path patterns are consistent with the  URL Pattern API Syntax: https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API\n * @param baseURL - Base url for the page (eg. www.youtube.com). All paths are appended to this when matching URls\n * @param currentPageData - Contains data relevant to the current page.\n * @param interactionAttribute - Attribute added to all elements being monitored\n */\nexport class Monitor {\n    constructor(configLoader) {\n        /**\n       * Generates a unique color from a given string\n       * Source: https://stackoverflow.com/a/31037383\n       * @returns Color hex code\n       */\n        this.StringToColor = (function () {\n            let instance = null;\n            return {\n                next: function stringToColor(str) {\n                    if (instance === null) {\n                        instance = {};\n                        instance.stringToColorHash = {};\n                        instance.nextVeryDifferntColorIdx = 0;\n                        instance.veryDifferentColors = [\"#00FF00\", \"#0000FF\", \"#FF0000\", \"#01FFFE\", \"#FFA6FE\", \"#FFDB66\", \"#006401\", \"#010067\", \"#95003A\", \"#007DB5\", \"#FF00F6\", \"#FFEEE8\", \"#774D00\", \"#90FB92\", \"#0076FF\", \"#D5FF00\", \"#FF937E\", \"#6A826C\", \"#FF029D\", \"#FE8900\", \"#7A4782\", \"#7E2DD2\", \"#85A900\", \"#FF0056\", \"#A42400\", \"#00AE7E\", \"#683D3B\", \"#BDC6FF\", \"#263400\", \"#BDD393\", \"#00B917\", \"#9E008E\", \"#001544\", \"#C28C9F\", \"#FF74A3\", \"#01D0FF\", \"#004754\", \"#E56FFE\", \"#788231\", \"#0E4CA1\", \"#91D0CB\", \"#BE9970\", \"#968AE8\", \"#BB8800\", \"#43002C\", \"#DEFF74\", \"#00FFC6\", \"#FFE502\", \"#620E00\", \"#008F9C\", \"#98FF52\", \"#7544B1\", \"#B500FF\", \"#00FF78\", \"#FF6E41\", \"#005F39\", \"#6B6882\", \"#5FAD4E\", \"#A75740\", \"#A5FFD2\", \"#FFB167\", \"#009BFF\", \"#E85EBE\"];\n                    }\n                    if (!instance.stringToColorHash[str]) {\n                        instance.stringToColorHash[str] = instance.veryDifferentColors[instance.nextVeryDifferntColorIdx++];\n                        console.log(`%c The colour for ${str}`, `color: ${instance.stringToColorHash[str]}`);\n                    }\n                    return instance.stringToColorHash[str];\n                }\n            };\n        })();\n        const config = configLoader.config;\n        this.interactionEvents = config.events ? config.events : ['click'];\n        this.highlight = true;\n        this.paths = config.paths;\n        this.baseURL = config.baseURL;\n        this.currentPageData = new PageData();\n        this.interactionAttribute = \"monitoring-interactions\";\n        this.extractorList = configLoader.extractorList;\n        // Check if this page should be monitored\n        // if (window.location.origin === this.baseURL) {\n        //     this.initializeMonitor();\n        // } else {\n        //     console.log(`Skipping monitoring. Current origin (${window.location.origin}) does not match base URL (${this.baseURL}).`);\n        // }\n        if (window.location.origin === this.baseURL) {\n            const runWhenVisible = () => {\n                if (document.visibilityState === 'visible') {\n                    this.initializeMonitor();\n                    document.removeEventListener('visibilitychange', runWhenVisible);\n                }\n            };\n            if (document.readyState === 'complete') {\n                runWhenVisible();\n            }\n            else {\n                window.addEventListener('load', runWhenVisible);\n            }\n            document.addEventListener('visibilitychange', runWhenVisible);\n        }\n    }\n    /**\n     * Initializes the monitor if base URL matches the current URL\n     */\n    async initializeMonitor() {\n        this.updateCurrentPageData(document.location.href);\n        try {\n            // Creates a new entry in the DB describing the state at the start of the session\n            await this.initializeSession();\n            // Binds listeners to the HTML elements specified in the config for all matching path patterns\n            this.bindEvents();\n        }\n        catch (err) {\n            console.error(\"Failed to initialize session:\", err);\n        }\n    }\n    /**\n   * Updates the page data whenever a new page is detected\n   * @param url - the url of the new page\n   */\n    updateCurrentPageData(url) {\n        this.currentPageData.update(this.baseURL, url, this.paths);\n    }\n    /**\n   * Creates a new entry in the DB describing the state at the start of the session\n   */\n    async initializeSession() {\n        const currentState = new SessionDocument(this.currentPageData.url, document.title);\n        console.log(\"Checking highlight\");\n        const response = await this.sendMessageToBackground(SenderMethod.InitializeSession, currentState);\n        this.highlight = response.highlight;\n        // console.log(`Highlight is set to ${this.highlight}`)\n    }\n    /**\n   * Binds event listeners for mutations and navigation\n   */\n    bindEvents() {\n        // Whenever new content is loaded, attach observers to each HTML element that matches the selectors in the configs\n        const observer = new MutationObserver((mutations, obs) => this.addListenersToNewMatches());\n        // Make the mutation observer observe the entire document for changes\n        observer.observe(document.body, {\n            childList: true,\n            subtree: true\n        });\n        // Add an event listener to detect navigations on the page\n        // @ts-ignore: Ignoring TypeScript error for navigation not found\n        navigation.addEventListener(\"navigate\", (e) => this.onNavigationDetection(e));\n    }\n    /**\n   * Adds listeners to mutations (ie. newly rendered elements) and marks them with this.interacttionAttribute.\n   * If debug mode is on, this will add a colourful border to these elements.\n   */\n    addListenersToNewMatches() {\n        // console.log(\"adding selectors\");\n        // console.log(`Value of highlight: ${this.highlight}`);\n        // console.log(\"Current page data:\");\n        // console.log(this.currentPageData);\n        this.currentPageData.selectors.forEach(interaction => {\n            let elements = document.querySelectorAll(`:is(${interaction[\"selector\"]}):not([${this.interactionAttribute}])`);\n            let name = interaction[\"name\"];\n            elements.forEach(element => {\n                if (this.highlight)\n                    element.style.border = `2px solid ${this.StringToColor.next(name)}`;\n                element.setAttribute(this.interactionAttribute, 'true');\n                for (let i = 0; i < this.interactionEvents.length; i++) {\n                    element.addEventListener(this.interactionEvents[i], (e) => {\n                        this.onInteractionDetection(element, e, name);\n                    }, true);\n                }\n            });\n        });\n    }\n    /**\n   * Sends a message to the background script.\n   * @param event - the HTML event that occured\n   * @returns A document describing the state change\n   */\n    createStateChangeRecord(event) {\n        console.log(\"Detected state change event\");\n        const metadata = this.extractorList.extract(this.currentPageData.url, SenderMethod.NavigationDetection);\n        console.log(\"printing metadata\");\n        console.log(metadata);\n        return new ActivityDocument(ActivityType.StateChange, event, metadata, this.currentPageData.url, document.title);\n    }\n    /**\n   * Sends a message to the background script.\n   * @param event - the HTML event that occured\n   * @param urlChange - indicates whether the self-loop resulted in a url change\n   *\n   * @returns A document describing self loop\n   */\n    createSelfLoopRecord(event, urlChange) {\n        console.log(\"Detected self loop change event\");\n        const metadata = this.extractorList.extract(this.currentPageData.url, SenderMethod.NavigationDetection);\n        console.log(\"printing metadata\");\n        console.log(metadata);\n        return new ActivityDocument(ActivityType.SelfLoop, event, metadata, this.currentPageData.url, document.title);\n    }\n    /**\n   * Sends a message to the background script.\n   * @param element - the element that triggered the event\n   * @param name - the name of the element that triggered the callback (as defined in the config)\n   * @param event - the HTML event that occured\n   * @returns A document interaction self loop\n   */\n    createInteractionRecord(element, name, event) {\n        console.log(\"Detected interaction event\");\n        let metadata = {\n            html: element.getHTML(),\n            elementName: name,\n        };\n        let extractedData = this.extractorList.extract(this.currentPageData.url, SenderMethod.InteractionDetection);\n        metadata = Object.assign(Object.assign({}, metadata), extractedData);\n        console.log(\"printing metadata\");\n        console.log(metadata);\n        return new ActivityDocument(ActivityType.Interaction, event, metadata, this.currentPageData.url, document.title);\n    }\n    /**\n   * Sends a message to the background script.\n   * @param sender - the name of the function that's sending the message to the background script\n   * @param payload - the data being sent to the background script\n   *\n   * @returns Response indicating whether the message succeeded\n   */\n    async sendMessageToBackground(senderMethod, payload) {\n        let message = new BackgroundMessage(senderMethod, payload);\n        const response = await chrome.runtime.sendMessage(message);\n        return response;\n    }\n    /**\n   * Callback that creates a payload describing the interaction that occured and sends it to the background script\n   * @param e - the event that triggered the callback\n   * @param name - the name of the element that triggered the callback (as defined in the config)\n   */\n    onInteractionDetection(element, e, name) {\n        console.log(\"interaction event detected\");\n        console.log(`Event detected with event type: ${e.type}`);\n        console.log(`Event triggered by ${element}`);\n        // console.log(element.innerHTML);\n        // console.log(element.getHTML());\n        const record = this.createInteractionRecord(element, name, e);\n        this.sendMessageToBackground(SenderMethod.InteractionDetection, record);\n    }\n    /**\n     * Callback that creates a payload describing the navigation that occured and sends it to the background script\n     * @param e - the event that triggered the callback\n     * @param name - the name of the element that triggered the callback (as defined in the config)\n     */\n    onNavigationDetection(navEvent) {\n        let baseURLChange = navEvent.destination.url.split(\".\")[1] != this.currentPageData.url.split(\".\")[1];\n        let urlChange = !(navEvent.destination.url === this.currentPageData.url);\n        // let sourceState = this.getCleanStateName();\n        // let match = this.currentPageData.checkForMatch(navEvent.destination.url);\n        this.currentPageData.url = navEvent.destination.url;\n        // let destState = this.getCleanStateName();\n        console.log(`Navigation detected with event type: ${navEvent.type}`);\n        if (baseURLChange) {\n            console.log(\"URL base change detected. Closing program.\");\n            this.sendMessageToBackground(SenderMethod.CloseSession, new DBDocument(this.currentPageData.url, document.title));\n        }\n        else if (navEvent.navigationType === \"push\") {\n            console.log(\"Push event detected.\");\n            const record = this.createStateChangeRecord(navEvent);\n            this.sendMessageToBackground(SenderMethod.NavigationDetection, record);\n            this.updateCurrentPageData(this.currentPageData.url);\n        }\n        else if (navEvent.navigationType === \"replace\") {\n            console.log(\"Replace event detected.\");\n            const record = this.createSelfLoopRecord(navEvent, urlChange);\n            this.sendMessageToBackground(SenderMethod.NavigationDetection, record);\n        }\n    }\n}\n","/**\n * A class responsible for tracking the state of the page that the user is currently on.\n */\nexport class PageData {\n    /**\n     * Updates the state of the PageData\n     * @param baseURL: The base url for the page (eg. www.youtube.com)\n     * @param url: The full url of the current page\n     * @param paths: A list of all the paths defined in a config\n     */\n    update(baseURL, url, paths) {\n        this.url = url;\n        let matches = this.updateMatchData(baseURL, paths);\n        this.selectors = this.getSelectors(matches, paths);\n    }\n    /**\n     * Sets `matchPathData` to be the PathData for the URL pattern with the closet match to `baseURL`\n     * and returns a list of all matches. Additionally, it updates whether the current path\n     * includes an id.\n     * @param baseURL: The base url for the page (eg. www.youtube.com)\n     * @param paths: A list of all the paths defined in a config\n     *\n     * @returns A list of all paths in the config that match `baseURL`\n     */\n    updateMatchData(baseURL, paths) {\n        console.log(\"updating page data\");\n        let closestMatch = \"\"; // the pattern that most closely matches the current URL\n        // Get a list of all the paths that match the current URL\n        const matches = Object.keys(paths).filter((path) => {\n            // console.log(path);\n            // @ts-ignore: Ignoring TypeScript error for URLPattern not found\n            const p = new URLPattern(path, baseURL);\n            const match = p.test(this.url);\n            // Closest match is the longest pattern that matches the current URL\n            if (match && path.length > closestMatch.length) {\n                closestMatch = path;\n            }\n            return match;\n        });\n        this.currentPath = closestMatch;\n        if (matches.length === 0) {\n            console.log(\"no matches found\");\n        }\n        // this.urlUsesId = closestMatch.endsWith(\":id\");\n        this.matchPathData = paths[closestMatch];\n        return matches;\n    }\n    /**\n     * @returns Result of if it exsits`matchPathData.idSelector`, else it returns an empty string\n     */\n    extractData() {\n        var _a, _b;\n        console.log(`Current closest match is ${this.currentPath}`);\n        console.log(\"Trying to extract data\");\n        return ((_b = (_a = this.matchPathData).dataExtractor) === null || _b === void 0 ? void 0 : _b.call(_a)) || {};\n    }\n    /**\n     * @param matches: A list of all matching paths to the current url\n     * @param paths: A list of all the paths defined in a config\n     *\n     * @returns A list of all selectors for the matching paths\n     */\n    getSelectors(matches, paths) {\n        let currentSelectors = [];\n        for (const path of matches) {\n            let pathData = paths[path];\n            if (pathData[\"selectors\"]) {\n                for (const selector of pathData[\"selectors\"]) {\n                    currentSelectors.push(selector);\n                }\n            }\n        }\n        return currentSelectors;\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Monitor } from \"./interactions/monitor\";\nimport ytConfig from './configs/youtube_config.json';\nimport { ConfigLoader, ExtractorData } from \"./interactions/config\";\nimport { SenderMethod } from \"./communication/sender\";\nconst getHomepageVideos = () => {\n    // console.log(\"---- EXTRACTING HOMEPAGE LINKS ---\");\n    const contentDivs = Array.from(document.querySelectorAll('#content.ytd-rich-item-renderer'))\n        .filter(div => {\n        // Check if element is actually visible\n        const rect = div.getBoundingClientRect();\n        return rect.width > 0 && rect.height > 0 &&\n            getComputedStyle(div).visibility !== 'hidden';\n    });\n    const videos = contentDivs.map(contentDiv => {\n        var _a, _b, _c;\n        // Get the direct anchor child\n        const anchor = contentDiv.querySelector(':scope > yt-lockup-view-model a');\n        const span = contentDiv.querySelector('h3 a span.yt-core-attributed-string');\n        return {\n            link: (_a = anchor === null || anchor === void 0 ? void 0 : anchor.href) !== null && _a !== void 0 ? _a : '',\n            title: (_c = (_b = span === null || span === void 0 ? void 0 : span.textContent) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : ''\n        };\n    }).filter(video => video.link !== '');\n    return { \"videos\": videos };\n};\nconst getRecommendedVideos = () => {\n    console.log(\"---- EXTRACTING RECOMMENDED LINKS ---\");\n    const contentDivs = Array.from(document.querySelectorAll('yt-lockup-view-model')).filter(div => {\n        // Check if element is actually visible\n        const rect = div.getBoundingClientRect();\n        return rect.width > 0 && rect.height > 0 &&\n            getComputedStyle(div).visibility !== 'hidden';\n    });\n    const videos = contentDivs.map(contentDiv => {\n        var _a, _b, _c;\n        // Get the anchor with the video link\n        const anchor = contentDiv.querySelector('a[href^=\"/watch\"]');\n        const span = contentDiv.querySelector('h3 a span.yt-core-attributed-string');\n        return {\n            link: (_a = anchor === null || anchor === void 0 ? void 0 : anchor.href) !== null && _a !== void 0 ? _a : '',\n            title: (_c = (_b = span === null || span === void 0 ? void 0 : span.textContent) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : ''\n        };\n    }).filter(video => video.link !== '');\n    // console.log(\"Printing the first 5 videos\");\n    // console.table(videos.slice(0,5));\n    return { \"videos\": videos };\n};\nconst extractors = [new ExtractorData(SenderMethod.InteractionDetection, \"/\", getHomepageVideos),\n    new ExtractorData(SenderMethod.InteractionDetection, \"/watch?v=*\", getRecommendedVideos)];\nconst ytConfigLoader = new ConfigLoader(ytConfig, extractors);\nconst ytInteractor = new Monitor(ytConfigLoader);\n// const tiktokIDSelector = (): object => {\n//     let vid = document.querySelector(\"div.xgplayer-container.tiktok-web-player\");\n//     if (!vid){\n//         console.log(\"no url found!\");\n//         return {};\n//     }\n//     let id = vid.id.split(\"-\").at(-1);\n//     let url = `https://tiktok.com/share/video/${id}`;\n//     return {\n//         \"uniqueURL\": url\n//     };\n// }\n// console.log(tiktokConfig);\n// const tiktokConfigLoader = new ConfigLoader(tiktokConfig);\n// tiktokConfigLoader.injectExtractor(\"/*\", tiktokIDSelector);\n// const tiktokInteractor = new Monitor(tiktokConfigLoader.config);\n// // console.log(tiktokConfig);\n// const linkedinConfigLoader = new ConfigLoader(linkedinConfig);\n// const linkedinInteractor = new Monitor(linkedinConfigLoader.config);\n"],"names":[],"sourceRoot":""}